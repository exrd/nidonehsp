
# クイックリファレンス

このドキュメントでは `nidonehsp` の文法や仕様について触れていきます。

なお、推奨エディタやスクリプトの実行についてはこのドキュメントでは扱いません。\
それら開発環境については[開発環境][1]を参照してください。

## 動作環境

最初に、`nidonehsp` のターゲットとする動作環境は次の表のとおりです。

||内容|
|:--|:--|
|プラットフォーム|Windows（動作確認はWindows10のみ）<br>HTML(emscripten)|
|アーキテクチャ|64/32 ビット（推奨64ビット）<br>※32ビットは各自でビルドが必要|
|描画バックエンド|OpenGL ES 3.0|

ライセンスについてはこのドキュメントの末尾を参照してください。

## 文法

`nidonehsp` ではプログラムはステートメントの集まりで、ステートメントは基本的には一行一行の命令を指します。

```nhsp:ステートメントについて
ステートメント0
ステートメント1
…
```

スクリプトに書かれたプログラムは、書かれた順番にステートメントが上から順に実行されていきます。

例えば、

```nhsp:ステートメントの実行
mes "Hello"// Hello と表示する
mes "World!"// World! と表示する
…
```

というようなスクリプトの場合、

- まず 1 行目の `mes "Hello"` の行が実行される
- 次の行の `mes "World!"` が実行される
- さらに次の行のステートメントの実行がされる
- …

というように動作します。

ステートメントは、大まかに次の 5 つに分類されます。

- 空白（コメントなど）
- 命令（コマンド）
- 変数への代入
- プログラムのフロー制御
- モジュールや関数、ラベルなどの定義・宣言

このうち、最後の定義・宣言については内容が広範に渡るため詳細は本節では説明しません.\
それらについてはモジュールと関数、ラベルについてをそれぞれ参照してください。

### 空のステートメント

一番原始的なステートメントとしては `何も書かない` ことです！

…と書くと冗談のように聞こえてしまうかもしれませんが、`何も書かなければ何も実行されない` というのは重要な性質です。

```nhsp:空のステートメント

```

このステートメントは何も処理をしません。

そんなステートメントは実際のスクリプトでは出てこないだろうと思われるかもしれません。\
ところが、それがかなり大量にでてきます。

スクリプトを書いていくと「どんな処理を書いたのか」を忘れないように、メモすることが多く、それらメモは `コメント` という「ステートメントとして解釈されない文」として残すためです。

ここでは空のステートメントの紹介をしましたが、続けて `コメント` 機能についてまず説明します。

`コメント` とは先述のとおり「ステートメントとして解釈されない文」ですが、より厳密に言うと `書いても無視されるスクリプトの一部分` となります。

`;（セミコロン）` または `//（スラッシュ 2 つ）` を書くと、そこからその行の行末までコメントとして認識されます。

```nhsp:コメント
; ここはコメント
// ここもコメント。ここに書いたものは無視される
なにかしらのステートメント// ここもコメントになる
```

このスクリプトは、次のスクリプトと同じ動作になります。

```nhsp:コメント


なにかしらのステートメント
```

コメントによって空行になり、何もしないステートメントとして処理される行が 3 行中 2 行になったのが分かるでしょうか？\
このように、実際は空行となって何も実行されないステートメントは思っていたより存在します。

行単位ではなく、行の一部分または行をまたいでコメントとして認識させたい場合、 `/*` から `*/` まで囲むことによって可能です。

```nhsp:コメント
/* ここはコメント
 ここもコメント。ここに書いたものは無視される
*/
```

### コマンドステートメント

命令とは、例えば `画面に文字を描画` や `赤色の四角形を描画` といった、一連の処理の指示（文字通り”命令すること”ですね）のことを指します。

`nidonehsp` には他にも `プログラムをすぐに終了` や `sinの値を計算` といった様々な命令がシステム側から提供されていますが、非常に広範な内容になるためここでは触れません。\
それらはヘルプビューとして検索できるようになっています、詳細については[開発環境][1]を参照してください。

命令のステートメントは、単純に命令名を最初に書きます。

```nhsp:命令
end// 実行を終了する
```

このスクリプトのように命令名だけ書けば動作するようなものもありますが、大半の命令はパラメータというものを受け取ります。

パラメータは命令の実行時に使う値のことです。

例えば `画面に文字を描画` という命令があった場合、命令側はどういう文字を描画すればいいのか（してほしいのか）分かりません。\
そこで、命令にパラメータという形で描画する文字列を指定します。

命令に対するパラメータは、命令名を書いた後に `' '（半角スペース）` をいれ、その後に書きます。

```nhsp:パラメータを持った命令
mes "Hello"// 画面に Hello と表示
```

パラメータが複数ある場合、そのパラメータは `,（カンマ）` で区切る必要があります。

```nhsp:複数パラメータの指定
mes "Hello", "World!"
```

※筆者注）\
なお、パラメータは”指定する”以外にもよく”（パラメータを）渡す”といった表現もされます。\
以降「パラメータを渡す」などといった表現が出てきた際は、「そのパラメータを指定する」のように適宜意味を読み変えて頂ければと思います。

### 変数代入

変数とは、誤解を恐れずに言えば `何かしらの値を保存しておくための領域` です。

`何かしらの値`とは、`0` や `12` といった数値の他、`"Hello"` といった文字列（`"（ダブルクォーテーション）`で括った値は文字列になります）などいくつか種類が存在します。

まずは、最も簡単な変数代入のステートメントを示します。

```nhsp:変数代入
a = 12// a に 12 という数値を保存
```

変数は、特に「変数が存在する」といった宣言をする必要はありません。\
変数代入など変数を使うステートメントが現れたとき、その変数が暗黙的に宣言されたと解釈されます。

変数は命令へのパラメータとして渡すことも可能です。

```nhsp:変数代入
a = 12// a に 12 という数値を保存
mes a// a の内容を表示
```

このスクリプトは、動作としては次のスクリプトと同じです。

```nhsp:変数代入
mes 12
```

なお、変数は**最初 `0` が代入された状態**になっています。

```nhsp:変数の暗黙的初期化
mes a// a の内容を表示
```

このスクリプトの結果は次のようになります。

```nhsp:変数の暗黙的初期化
0
```


### フロー制御

今までのスクリプトは全て、上から順番にステートメントを実行する、という動作になっていました。

しかし、このままでは例えば同じステートメントを 10 回実行させるためには、そのステートメントを 10 回書く必要がありました。\
それはとても大変ですね。

他にも、特定の条件下でのみステートメントを実行する（例えば`変数 a の中身が 0 だったらステートメントを実行`）といったこともできません。

そこで、これら `繰り返し` や `条件分岐` といった処理は、それ専用の特別な書き方をすることで実現できるようになっています。\
このための書き方及びその処理をフロー制御と呼びます。

#### 条件分岐

条件分岐のフロー制御には `if` を使います。

```nhsp:条件分岐のフロー制御
// a が 0 だったら Hello と表示
if a == 0 {
    mes "Hello"
}
```

`if` の後に条件分岐の判断をするための式を書き、その後は `{}（ブレース）` で条件式が成立した場合に実行されるステートメントを括ります。

また、条件式が不成立だった場合の処理も同時に書きたい場合、`else` を続けて書くことで実現できます。

```nhsp:条件分岐のフロー制御
// a が 0 だったら Hello と、a が 0 以外だったら World！ と表示
if a == 0 {
    mes "Hello"// 条件式が成立した時の処理
} else {
    mes "World!"// 条件式が不成立の時の処理
}
```

#### 繰り返し

繰り返しのフロー制御には `repeat` と `loop` を使います。

```nhsp:繰り返しのフロー制御
// 3 回 Hello と表示
repeat 3// この数字は繰り返す数
    mes "Hello"
loop
```

このスクリプトは、次のようなスクリプトと同じ挙動になります。

```nhsp
// 3 回 Hello と表示
mes "Hello"
mes "Hello"
mes "Hello"
```

3 回ぐらいの処理では記述を見比べてもあまり効果はないように感じるかもしれませんが、実際には繰り返しの回数は `repeat` を使った場合は 1 単語だけ書き換えればいいのに対し、直接書いた方ではその分コピー・ペーストする必要があり大変ですね。

繰り返し中、現在の繰り返し回数を表すシステム変数 `cnt` を使うことで、繰り返しの中での処理を更に細かく制御できます。\
システム変数とは、スクリプトの実行によって `nidonehsp` のシステム側が自動的に書き換える変数で、スクリプト側から読み取ることはできますが書き込む（代入）ことができない特殊な変数です。

```nhsp:繰り返しのフロー制御
// 3 回 Hello と表示
repeat 3
    mes "Hello" + cnt
loop
```

このスクリプトの実行結果は次のようになります。

```nhsp:繰り返しのフロー制御
Hello0
Hello1
Hello2
```

`cnt` は `0 からカウントがはじまる` ことに注意してください。

繰り返しにおいて、途中で繰り返しを止めたり、繰り返しの途中でそれ以降の処理をスキップしたいことがあります。\
その場合、繰り返しを止める場合は `break` キーワードを、今の繰り返しだけをスキップする場合は `continue` キーワードを使います。

```nhsp:繰り返しのフロー制御
// 5 回 Hello と表示
repeat 5
    if (cnt == 2) { continue }// が、 2 の時はスキップ
    mes "Hello" + cnt
    if (cnt == 3) { break }// そして 3 になったら繰り返しを止める
loop
```

このスクリプトの実行結果は次のようになります。

```nhsp:繰り返しのフロー制御
Hello0
Hello1
Hello3
```

このように繰り返しは特に条件分岐と組み合わせると非常に強力な機能です。\
また、プログラミングにおける基盤となるステートメントですので、ぜひ色々使いこんでみてください。

#### その他のフロー制御

ここで紹介した以外にもフロー制御の仕方はいくつか存在します。

…が、まだ網羅的に説明できる資料は存在していません。\
資料が出来次第随時クイックリファレンスも更新していく予定ですので、お手数ですがお待ちください。

### ステートメントの明示的な区切り

今までは全てのステートメントは行ごとに 1 つだけしか書いてきませんでした。\
しかし、場合によってはある程度まとまった処理は 1 行にまとめて書いた方がスクリプトを読む際に便利な場合もあります。

`nidonehsp` ではステートメントの区切りとして、改行以外に `:（コロン）` を使うこともできます。

例えば、次のようなスクリプトは、

```nhsp
mes "Hello"
mes "World!"
```

`:` を使って次のように書き直すことができます。

```nhsp
mes "Hello" : mes "World!"
```

これはフロー制御で出てきた `if` などにも使用可能で、`if` では `:` を使ってステートメントを連ねて書くと、そのステートメントを全て実行するようになります。

つまり、次のようなスクリプトは

```nhsp
if (a == 0) {// a が 0 なら、{} 内を実行
    mes "Hello"
    mes "World!"
}
```

`:` を使うと次のように書き直すことが出来ます。

```nhsp
if (a == 0) : mes "Hello" : mes "World!"
```

なお、`else` が途中ででてくる場合、`if` の条件式が成立した際に実行されるステートメントは `else` が出てくるまでのステートメントになり、`else` 以降のステートメントは条件式が不成立の場合に実行されます。

つまり、

```nhsp
if (a == 0) : mes "Hello" : mes "World!" : else : mes "Else" : mes "World"
```

というスクリプトは、

```nhsp
if (a == 0) {
    mes "Hello"
    mes "World!"
} else {
    mes "Else"
    mes "World"
}
```

と同じ動作になります。

`:` によるステートメントの明示的な区切りは、うまく使えば見やすいスクリプトを書くことができる一方、一見正しく見えるが意図しない挙動をするプログラムにもなることがあります。\
典型的には 2、3 個の意味のまとまったステートメントは `:` 区切りで一行にまとめ、それ以外のステートメントは一行 1 ステートメントを基本とするのがよいでしょう。

## 式と値

この節では数値や文字列といった値や式の書き方についてより詳細に説明していきます。

### 数値

数値はスクリプト中では半角数字を使って記述します。

```nhsp:数値の例
10// これは整数値の 10
-12// これは整数値の -12
22.2// これは実数値の 22.2
```

`0x` または `$` から始めると 16 進数で値を記述できます。

```nhsp:16 進数の例
0xff// 整数値の 255
$81c// 整数値の 2076
```

`'（シングルクォーテーション）`で括った文字はその文字のユニコードにおけるコードポイントを表します。

```nhsp:文字コードポイントの例
' '// 整数値の 32、半角スペースのASCIIコード
'ソ'// 整数値の 12477、ソのユニコードコードポイント（U+30BD）
```

### 文字列

文字列は`"（ダブルクォーテーション）`で括って記述します。

```nhsp:文字列の例
"Hello"// 文字列 Hello
"This is Sample String"// 文字列 This is Sample String
```

`"`で括った文字列は行をまたぐことができません。\
そのため、文字列に改行など一部の特殊な文字を含めたい場合、`\（バックスラッシュ）`から始まるエスケープシーケンスと呼ばれる記述をする必要があります。

文字列中で利用できるエスケープシーケンスは次の表のとおりです。

|エスケープシーケンス|意味|
|:--|:--|
|`\\0`|ヌル文字|
|`\\n`|改行|
|`\\t`|タブ文字|
|`\\'`|シングルクォーテーション|
|`\\"`|ダブルクォーテーション|
|``\\` ``|バッククォーテーション|
|`\\\\`|文字 `\\` |
|`\xXX`|`XX` を 16 進数として評価した文字|
|`\uXXXX`|`XXXX` を 16 進数として評価したコードポイントのユニコード文字|
|`\UXXXXXXXX`|`XXXXXXXX` を 16 進数として評価したコードポイントのユニコード文字|

`{"` から `"}` で括ることで複数行の文字列を記述できます。

```nhsp:複数行文字列の例
{"Hello
World!"}
/* 文字列
Hello
World!
*/
```

`` `（バッククォーテーション） ``で括ることで複数行の文字列を記述できます。\
また、この文字列中に限り `${` と `}` で括った箇所は式として評価され、文字列化したものが挿入されます。

```nhsp:テンプレート文字列の例
`Hello${10 + 2}
World!`
/* 文字列
Hello12
World!
*/
```

この機能をテンプレート文字列と呼びます。

### ラベル

`*（アスタリスク）`から始まる識別子はラベルになります。

```nhsp:ラベルの例
*label// label という名前のラベル
```

### nil

`nil` はキーワードで、nil型の値になります。

```nhsp:nilの例
nil// nil 型の値
```

### 演算

これまでで説明したものが値として解釈できるものでしたが、ここからは値同士の演算について説明していきます。

まずは簡単なものから、数値同士の四則演算は当然サポートされています。

```nhsp:数値の四則演算
1 + 2// = 3
1 - 2// = -1
2 * 8// = 16
4 / 3// = 1
```

ここで、最後の例で `4 / 3` の結果が `1` であり、`1.3333...` ではないことに注意してください。\
`4 / 3` は整数 `4` を整数 `3` で割った商で、答えも整数値になるため、`1.3333...` を小数点以下切り捨てし `1` と処理されたのです。

`nidonehsp` においてほぼ全ての演算は、**左項の型に右項の値を変換して**演算が行われます。

例えば上記例での `4 / 3` を結果として実数値を得たい場合、`4.0 / 3` のように記述する必要があります。

もう 1 つ例を挙げておきましょう。\
`10 + "24"` のような演算の場合、右項の `"24"` は数値型に変換されるため、`10 + 24` となり結果として `34` になります。

型の変換ルールについては後述の型変換を参照してください。

`nidonehsp` でサポートされる演算は次の表の通りです。

|演算子|内容|整数|実数|文字列|ラベル|nil|備考|
|:--|:--|:--|:--|:--|:--|:--|:--|
|`+`|加算|〇|〇|〇|×|×||
|`-`|減算|〇|〇|×|×|×||
|`*`|乗算|〇|〇|×|×|×||
|`/`|除算|〇|〇|×|×|×|ただし`0`で割った場合エラー|
|`\`|剰余|〇|〇|×|×|×||ただし`0`で割った場合エラー|
|`\|`|ビット和|〇|×|×|×|×||
|`&`|ビット積|〇|×|×|×|×||
|`^`|ビット排他的論理和|〇|×|×|×|×||
|`==`<br>`!=`|等号<br>不等号|〇|〇|〇|〇|〇|結果は`0`または`1`|
|`>`<br>`>=`<br>`<`<br>`<=`|比較|〇|〇|〇|×|×|結果は`0`または`1`|
|`>>`<br>`<<`|ビットシフト|〇|×|×|×|×|符号付ビットシフト|
|`-`|単項負|〇|〇|×|×|×||

また、型によらず適用できる演算は次の表の通りです。

|演算子|内容|備考|
|:--|:--|:--|
|`a then b else c`|`a`が`true`として評価できるなら`b`を、そうでないなら`c`を返す|三項演算<br>（条件演算）|
|`\|\|`|論理和<br>左項が`true`として評価できるなら左項を、そうでないなら右項を返す|短絡評価|
|`&&`|論理積<br>左項が`true`として評価できるなら右項を、そうでないなら左項を返す|短絡評価|
|`!`|論理否定<br>項が`true`として評価できるなら`0`を、そうでないなら`1`を返す|単項演算|

※型が`true`として評価できるかは後述の型特性を参照してください。

全演算子の優先度は次の表の通りです。\
表の上にあるものの方が優先度が低いです。

|演算子|結合方向|備考|
|:--|:--|:--|
|`a then b else c`|右||
|`\|\|`, `&&`|左||
|`^`, `\|`, `&`|左||
|`==`, `!=`|左||
|`<`, `<=`, `>`, `>=`|左||
|`<<`, `>>`|左||
|`+`, `-`|左||
|`*`, `/`, `\`|左||
|`!`, `-`||単項演算子|

### 型の変換

明示的な型の変換には組み込み関数を使います。\
関数なので詳細についてはヘルプビューを参照していただければと思いますが、非常に一般的な操作なのでこのドキュメントでも簡単に触れておきます。

それぞれの型への変換処理は次の通りです。

|型|変換関数|サンプル|備考|
|:--|:--|:--|:--|
|整数|`int()`|`int(22.4)` ＝> `22`|nil：`0`<br>文字列：数値として解釈できないなら`0`<br>ラベル型、モジュール変数型はエラー|
|実数|`double()`|`double(22)` ＝> `22.0`|nil：`0.0`<br>文字列：数値として解釈できないなら`0.0`<br>ラベル型、モジュール変数型はエラー|
|文字列|`str()`|`str(22.4)` ＝> `"22.4000"`|nil: `"nil"`<br>ラベル型、モジュール変数型はエラー|
|ラベル|なし||ラベル型以外からの変換はエラー|
|モジュール変数|なし||モジュール変数型以外からの変換はエラー|

また、文字列への変換について、例えば小数点以下の桁数などより細かく制御したい場合は `strf()` 関数を参照してください。

### 型特性

型ごとのストレージサイズ、真偽としての評価値などについて、次の表にまとめてあります。

|型|型名|ストレージサイズ\[byte\]|真偽|備考|
|:--|:--|:--|:--|:--|
|nil|`nil`|0|常に`false`||
|整数|`int`|8|`0` なら`false`<br>それ以外`true`||
|実数|`double`|8|`0` なら`false`<br>それ以外`true`||
|文字列|`str`|可変|整数に変換してから評価||
|ラベル|`label`|固定<br>プラットフォーム依存|有効なラベルなら`true`<br>それ以外`false`||
|モジュール変数|`struct` または<br>`modinst`|可変|有効なインスタンスなら`true`<br>それ以外`false`||

型名は `vartype` などで文字列で指定した時に使用できます。

なお、**整数型である `int` のストレージサイズが 8 byteであり、HSP3とは互換性がない**ことに注意してください。\
`int` が 8 byteのため、64bit環境でもポインタを格納できる型になっています。

## 変数

変数代入のステートメントにて変数について簡単に説明しましたが、この節ではより詳細に変数について説明していきます。

### 変数の型

変数の型は、変数への値の代入時に自動で変化します。

```nhsp:変数代入と型
a = 10// ここでは変数 a の型は整数
a = "Hello"// ここで変数 a の型は文字列になる
```

### 配列変数

今まで変数には 1 つの値しか入れてきませんでしたが、実は変数には同じ型であれば複数の値を入れることが出来ます。

この複数の値を入れることが出来る変数を配列変数と言います。\
*※つまり、`nidonehsp` において現状変数は全て配列変数です。*

配列変数には複数の要素が入っていますが、それぞれの要素には変数名の後に`()`でその要素の番号（インデックスとも言います）を指定することで読み込み・書き込みすることが出来ます。

```nhsp:配列変数への代入
a(0) = 10// a の 0 番目の要素に 10 を代入
a(1) = 12// a の 1 番目の要素に 12 を代入
// 変数の中身を表示
repeat 2
    mes `a(${cnt})=${a(cnt)}`
loop
```

このスクリプトの実行結果は次のようになります。

```nhsp:配列変数への代入
a(0) = 10
a(1) = 12
```

何もしなくても変数の配列要素に読み込み・書き込みできていることに注意してください。

*※配列要素へのアクセスにはHSP3の `.（ドット）` を使った記法は使用できません。*

変数は、**整数・実数型の場合デフォルトで 16 要素、文字列の場合デフォルトで 1 要素を持つ配列変数**となっています。

なお、変数要素に対して型の違う値を代入しようとするとエラーになります。

```nhsp:配列要素への異なる型の代入
a = 10// a は整数型である
a(1) = 22.2// a の要素に実数型を代入しようとした <= ここでエラー
```

配列変数のサイズを明示的に指定したい場合、例えば整数型だが要素数を 16 より大きくしたい場合などには、組み込み関数の `dim` や `ddim` を使います。

詳細はヘルプビューを参照していただくとして、ここでは簡単なサンプルを示します。

```nhsp:配列要素の動的確保
dim a, 256// a を整数型 256 要素を持つ配列変数として初期化
ddim a, 1024// a を実数型 1024 要素を持つ配列変数として初期化
```

配列変数の連続した要素に対して代入をしたい場合、`,（カンマ）`区切りで値を書くことで実現できます。

```nhsp:配列要素への一括代入
a = 1, 1, 2, 3, 5, 8, 13
repeat 7
    mes `a(${cnt})=${a(cnt)}`
loop
```

このスクリプトの実行結果は次のようになります。

```nhsp:配列要素への一括代入
a(0) = 1
a(1) = 1
a(2) = 2
a(3) = 3
a(4) = 5
a(5) = 8
a(6) = 13
```

<hr>

配列変数はここまでで 1 次元の配列として使ってきましたが、実は全て配列変数は 4 次元まで次元を持つことが出来ます。

例えば 2 次元の配列変数を作って値を代入する場合は次のようになります。

```nhsp:2次元の配列変数
ddim a, 2, 3// 2 x 3 の次元の配列変数として初期化

// それぞれの要素に値を代入して内容を描画
repeat 2 : x = cnt : repeat 3 : y = cnt
	a(x, y) = 2.0 * x  + 3.0 * y
    mes `a(${x}, ${y})=${a(x, y)}`
loop : loop
```

## ラベルを使ったフロー制御

これまでラベルは値としてのラベルのみ使い道を説明してきましたが、本来のラベルの使い道はプログラムでの位置を表すものです。

ラベルのみ（`*から始まる識別子`）のステートメントは、新たにラベルの定義が行われ、そのラベルが指すプログラムの位置はそのステートメントの位置になります。

```nhsp:ラベルの宣言・定義
*newLabel// ここで新しく *newLabel というラベルが作られる
```

このラベルは主に `goto` と `gosub` という 2 つのフロー制御のためのキーワードで使われます。

`goto` はその後にラベルを指定し、このフロー制御によって次に実行されるのは指定したラベルの直後のステートメントになります。

例えば、次のような `goto` を使ったスクリプトがあるとします。

```nhsp:ラベルの宣言・定義
goto *newLabel// *newLabel の位置へ”飛ぶ”
mes "after goto *newLabel"
*newLabel
mes "after *newLabel"
```

このスクリプトの実行結果は次のようになります。

```nhsp:ラベルの宣言・定義
after *newLabel
```

つまり、`goto *newLabel` によって次に実行されるステートメントが `*newLabel` の次のステートメントからになり、結果として `mes "after goto *newLabel"` というステートメントがスキップされ、実行されなくなりました。

なお、ラベルの宣言・定義はコンパイル時（スクリプトの解釈時）に行われ、実行時はラベルは何も処理がされないことに注意してください。

今までステートメントは必ず何らかの処理と結びついていましたが、このようにステートメントではあるが実行時には何もされず、解釈の時にだけ意味を持つステートメントも存在します。\
このようなステートメントは宣言ステートメントと呼んでいます。

<hr>

次に `gosub` について見ていきましょう。

`gosub` も `goto` と同じく指定したラベルへ処理をジャンプ（”飛ぶ”）させる命令ですが、`goto` と違い `gosub` した地点へ処理を戻すことができます。

`gosub` した後のどうなったら元の地点へ戻ればいいかはスクリプト側からしか分からないため、`gosub` される用のラベルではその後に元の地点へ戻るために `return` キーワードによるステートメントが必要になります。

まずは例を見てみましょう。

```nhsp:gosubによるラベルジャンプ
gosub *newLabel// *newLabel の位置へ”飛ぶ”
mes "after gosub *newLabel"
stop// ここで処理をストップ

*newLabel
mes "after *newLabel"
return
```

このスクリプトの実行結果は次のようになります。

```nhsp:gosubによるラベルジャンプ
after *newLabel
after gosub *newLabel
```

`gosub *newLabel` によって処理が一度 `*newLabel` の次のステートメントへ飛びます。

飛んだ先のステートメントは `mes "after *newLabel"` なのでこのステートメントを実行後、更に次のステートメント `return` を実行します。

`return` によって `gosub *newLabel` に戻ってきますが、既にそのステートメントの処理は終わっているので、次のステートメントの `mes "after gosub *newLabel"` が実行されます。

そして、最終的に `stop` 命令によって実行が中断されます。

*※なお、この `stop` がないとその次のステートメントが順に実行されますが、最後の `return` で `戻る先がない` 旨のエラーになります、興味がある方は試してみてください。*

`goto` は `repeat` や `if` にとらわれない非常に柔軟なフロー制御ができる一方、`gosub` は戻ってくることが前提になるため、**スクリプト中何度も出てくる処理を一か所にまとめることができる**ようになります。

*※なお、このように `gosub` で処理が飛んできて、元に戻ることを前提とした一連の処理はしばしば `サブルーチン` と呼ばれます。\
`nidonehsp` ではサブルーチンという単語は基本的にでてきませんが、HSP3ではこの単語は使われており、今日でも使われる単語です。*

`gosub` では一連の処理を纏めることが出来る一方、一連の処理の一部だけ挙動を変える際は何かしら変数の値を参照する必要があります。\
そうすると、`gosub` を呼び出す前に特定の変数の値を書き換える必要がある…、といった規則が増えてしまい、管理がとても大変になってしまいそうですね。

そういった一連の処理だけれども、処理内容を変更できるように、処理内容を変えるフラグをパラメータ化したい場合は、ラベルではなく独自にコマンド・関数定義ができるので、そちらを参照してください。

## コマンド・関数定義

これまでサンプルにて `mes` や `stop` などいくつか命令がでてきましたが、これらは予めシステム側が用意した命令です。

これら命令は実はスクリプト内でも新たに宣言・定義することが可能です。

新しく命令を宣言するには `#deffunc` を使います。

```nhsp:命令定義
#deffunc newFunc
    mes "Message from newFunc"
    return
```

こうして定義された命令は、スクリプトからコマンドや関数として呼び出すことが可能です。

```nhsp:命令定義
newFunc// newFuncを呼び出す
stop

#deffunc newFunc
    mes "Message from newFunc"
    return
```

命令定義においてはまず、ラベルのように `#deffunc` で新しく命令を宣言・定義します。

その後、`#deffunc` でつけた名前は命令として登録され、ステートメントにてコマンドとして記述できるようになります。

この例だけだとパラメータがなくラベルと出来ることが変わりませんので、この命令にてパラメータを受け取れるようにしましょう。

命令のパラメータ定義は、命令名の後に続けて型名とパラメータ名を記述します。

```nhsp:パラメータあり命令定義
newFunc 10// newFuncを呼び出す
stop

#deffunc newFunc int paramA
    mes `Message from newFunc(${paramA})`
    return
```

このスクリプトの実行結果は次のようになります。

```nhsp:パラメータあり命令定義
Message from newFunc(10)
```

パラメータとして渡した値が無事命令内から読み取りできています。

複数パラメータを持つ場合は、`,（カンマ）`で区切ってパラメータを宣言します。

```nhsp:パラメータあり命令定義
newFunc 10// newFuncを呼び出す
stop

#deffunc newFunc int paramA, double paramB = 22.2
    mes `Message from newFunc(${paramA}, ${paramB})`
    return
```

また、パラメータの名前の後、`=（等号）` と続けて書くことで、何も渡されなかった時のデフォルト値を設定することもできます。

`#deffunc` で使用できる型名やより詳細な書き方については、ヘルプビューの `#deffunc` を参照してください。

## モジュール

モジュールには大きく 2 つの意味合いがあります。

1 つは、関数や変数が所属する名前空間としてのモジュール、\
もう 1 つは、モジュール変数の元となる型としてのモジュールです。

### モジュールの宣言・定義

まず文法としてモジュールの宣言・定義の仕方について先に説明します。

モジュールは `#module` ではじまり、必ず `#global` で必ず閉じる必要があります。

```nhsp:モジュール定義
// 新しいモジュール newModule の定義
#module newModule
#global
```

`#module` の後にモジュール名を省略することもできます。\
その場合、システム側で自動でモジュール名が決められます。

*※デフォルトでは`_m0`というモジュール名が付けられます。\
無名モジュールが複数ある場合、最後の数字が連番として大きくなっていきます。*

### 名前空間としてのモジュール

今まで変数や関数についていた名前ですが、実はこれらは何かしらのモジュールに所属しています。

これらは通常意識する必要がないですが、**モジュール内のスクリプトは、自身が所属するモジュールの変数・関数を優先的に使う**というルールが存在します。

例えば、次のようなスクリプトを考えます。

```nhsp:名前空間モジュール
a = 10
printA
stop

#deffunc printA
    mes `a=${a}`
    return
```

このスクリプトの実行結果は次のようになります。

```nhsp:名前空間モジュール
a=10
```

ここで、この `printA` という関数を新たにモジュール `newModule` 内に入れてみましょう。

```nhsp:名前空間モジュール
a = 10
printA
stop

#module newModule
#deffunc printA
    mes `a=${a}`
    return
#global
```

こうするとそもそもコンパイルが通らなくなります。

2 行目の `printA` というコマンドステートメントにて、`printA` という命令が見つからないというエラーになります。

実は、`#deffunc printA` という関数定義が `#module newModule` の中に移動したため、`#module newModule` 外の名前空間とは違う場所に定義されたことになり、外側からその関数が見つからなくなってしまったです。

このエラーを修正するには 2 つのアプローチがあります。

まずは 1 つ目、`printA` の呼び出し側を、ちゃんと `newModule の printA` と明示することです。

特定のモジュール内に存在する関数を明示的に指定する場合、関数名とモジュールを `@` を挟んで記述することで指定できます。

```nhsp:名前空間モジュール
a = 10
printA@newModule
stop

#module newModule
#deffunc printA
    mes `a=${a}`
    return
#global
```

そしてもう 1 つの方法は、`#deffunc printA` での関数定義を、モジュール内だけでなくモジュール外からも見えるような関数として定義することです。

実は `#deffunc` には関数名の前に `global` と書くことでモジュール外も含めて見える関数を定義することができます。

このアプローチでエラーを修正すると次のようになります。

```nhsp:名前空間モジュール
a = 10
printA
stop

#module newModule
#deffunc global printA
    mes `a=${a}`
    return
#global
```

ここで、モジュールと名前空間について、もう少し深堀りしてみましょう。

`#module` から `#global` まで括った部分は、そのモジュールに属することになります。

より具体的には、**その区間で宣言・定義／参照した変数、関数、マクロについては全てそのモジュール空間に属す／属しているものを優先的に使おうとします**。

今回の例では、`#deffunc` によって宣言・定義した関数 `printA` は `newModule` というモジュールに所属しているため、フルネームは `printA@newModule` となっているのでした。

では、そもそも `#module` で括られてない部分はどこのモジュール空間にも所属してないのでしょうか？\
**いえ、実は何のモジュールにも括られてない箇所は、暗黙的にデフォルトのモジュールに所属することになっています。**

**デフォルトのモジュールの名前は `hsp` で、何のモジュールにも属してない区間のスクリプトは `hsp` というモジュール下にあると認識されます**。

そのため、今までサンプルで使ってきた変数 `a` などは、モジュールも含めたフルネームは実は `a@hsp` なのでした。

*※デバッガーでの変数名は全てフルネームなので、自分が書いたスクリプトの変数が実際にどの変数を指すのか分かる必要があります。*

さて、所属するモジュールによってフルネームが異なるのは分かりました。\
それが何故命令を呼び出す時に問題になるのでしょうか？

実は、命令を検索する順番は、

- まず自分の所属するモジュールの命令を検索する
- そこで見つからなかった場合、デフォルトのモジュールの命令を検索する

となっています。

つまり、デフォルトのモジュール下にあるスクリプトから `printA` という命令を呼び出そうとすると、

- まず自分の所属するモジュールの命令を検索する\
自分の所属するモジュールは `hsp` なので、`printA@hsp` を検索する
- 見つからなかったので、デフォルトのモジュール命令を検索する\
が、自分自身が既にデフォルトのモジュールに属しているので、この処理はスキップ

となり、結果的に `printA@hsp` を見つけることが出来なかったのです。

ここで、修正方法もそれぞれ見ておきましょう。

修正方法 1 はとても素直ですね。\
`printA` と書いて `printA@hsp` を検索してしまうので、そうではなく直接 `printA@newModule` と書くことで、定義した関数を探しに行ってもらう方法でした。

修正方法 2 はそれよりも少し難しいです。

`#deffunc` のあとに `global` を付けた場合、

- 所属するモジュールに関数を定義する
- デフォルトのモジュールにも自分の関数を定義する

という挙動になります。

つまり、`#deffunc global printA` としたことで、`printA@newModule` という関数と `printA@hsp` という関数が 2 つ定義され、どちらも同じ関数を指すようになったということです。

これにより、`printA@hsp` という関数が存在するので、モジュール外からも定義した関数が見えるようになったのでした。

<hr>

さて、エラーを修正し内容も解説したところでスクリプトに戻りましょう。\
エラーを修正したスクリプトの実行結果は次のようになります。

```nhsp:名前空間モジュール
a=0
```

無事コンパイルエラーが修正されました…が、結果も何か変なことになっていますね。

実は既に先述していますが、**関数以外に変数も自身の所属するモジュールのものを優先的に使用する**というルールがあります。

つまり、`printA@newModule` 内で参照している変数 `a` は実は `a@newModule` であり、1 行目で値を代入している変数 `a` は `a@hsp` なので、違う変数を参照している、というのが問題なのでした。

こうしたモジュールの名前空間機能に起因する挙動は少し難しいところがあり、モジュール機能については基礎ではなく応用になります。

ただ、モジュールとして独立させることでそれ以外のモジュールとの変数や関数を切り分けられる、というメリットも存在するので、他人にも共有して使ってもらいたいスクリプトなど、別途独立した機能として提供するスクリプトで主に使う想定となります。

*※ところで、組み込み命令の中には最後に `@n2` が付くものがあります。\
これは、それらの命令が HSP3 由来でデフォルトの `hsp` には存在せず、`nidonehsp` の独自拡張だよ、ということを明示するために敢えて別の名前空間に所属させています。*

## HSP3との挙動的な違い

HSP3とは挙動的に異なる箇所が非常に多いです。

基本的にはHSP3の挙動を踏襲しようとしていますが、この節では挙動や仕様が異なる点、書き分けや移行の際の注意点について説明していきます。

### int 型のサイズ

型特性で触れていますが、`nidonehsp` では `int` 型は 8 byte の整数値です。

そのため、値域が違うのは勿論、メモリレイアウトも異なる点に注意してください。

例えば、`dim a, 16` とした場合、変数サイズはHSP3では `4 * 16 = 64 byte` となりますが、`nidonehsp` では `8 * 16 = 128 byte` になります。\
これは DLL へ渡すメモリで `int` 型を使った場合、メモリレイアウトに互換性がないことを意味します。\
そのような用途の場合、`peek` や `poke` を使うことで直接メモリのオフセットとバイトを指定した読み書きが必要になります。

なお、`nidonehsp` では 8 byte 単位の読み書きのために `llpeek` と `llpoke` 命令が用意されています。

### 配列変数のメモリレイアウト

2 次元以上の配列変数のメモリレイアウトも異なります。

例えば `2 x 3` の配列のメモリレイアウトは、頭から順番に書くと HSP3 では

```
(0, 0), (1, 0), (0, 1), (1, 1), (0, 2), (1, 2)
```

のようになっていますが、`nidonehsp` では

```
(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)
```

のようになっています。

つまり、メモリの次元に対する優先順序が逆になっています。

### コマンドと関数

`nidonehsp` ではコマンドと関数は呼び出し時の挙動が異なるだけで、実体は 1 つであるというアプローチをとっています。\
*※mistから追ってくださっている方にはたぶんお馴染みの機能です。*

**全ての命令は疑似的にでも戻り値を持っており、コマンド形式で呼び出した場合は戻り値の型に応じてシステム変数へ値が代入され、関数形式で呼び出した場合はその戻り値がそのまま返ります。**

例えば、三角関数 `sin` は HSP3 では関数として定義されており `sin(deg2rad(10))` といった形でしか呼び出せませんが、`nidonehsp` では次のようにどちらでも呼び出し可能です（副作用が異なるだけです）。

```nhsp:コマンド呼びと関数呼び
a = sin(deg2rad(10))// a に sin の結果を代入
sin deg2rad(10)// 戻り値は時数なので refdval に結果を代入
```

コマンド呼びの戻り値の型とシステム変数への代入については次の表のとおりです。

|型|システム変数|
|:--|:--|
|nil|なし（副作用なし）|
|int|stat|
|double|refdval|
|str|refstr|

なお、`strsize` へ値を代入するといった特殊命令は互換性のため、それらのコマンドでは結果を数値として返すのではなく、`strsize` への代入を命令内で行い、戻り値としては `nil` を返すようになっています。

### エンコーディング

`nidonehsp` の内部エンコーディングは `UTF8` になっています。

スクリプトを読み込む際は `UTF8` の他、 `UTF16LE/BE` と `cp932` に対応しており、既存の HSP3 スクリプトは基本的に読み込める想定をしています。

ただし、読み込んだスクリプトは自動的に `UTF8` に変換されてから処理されるため、文字列等のメモリ内容は元のスクリプトが `cp932` であっても `UTF8` になります。

特に `cp932` いわゆる ShiftJIS とは違い `UTF8` では 1 文字で 2 byte を超過する可能性があるので、 ShiftJIS のエンコーディングに特化した処理とは互換性がない点に注意してください。

### 論理演算子

`nidonehsp` では `||` と `&&` をビット演算子ではなく論理演算子として実装されています。\
*※挙動については演算の項を参照してください。*

そのため、これらの演算子の結果が異なりますし、短絡評価される場合に項に含まれる関数の副作用が発生しない点も異なります。

あくまで単純に条件式として用いている場合は大きく挙動が変化することはないでしょう。

### HSP3 との使い分け

`nidonehsp` では HSP3 との互換性のため `__hspver__` や `__hsp30__` といったマクロを定義しているため、これらのマクロを見ただけでは `nidonehsp` か判断できません。

`nidonehsp` では独自に `__nhspver__` というマクロを定義しているため、スクリプト単位で挙動を分ける場合は

```nshp:nidonehspとHSP3の処理分岐
#ifdef __nhspver__
    // nidonehsp 時
#else
    // HSP3 時
#endif
```

といった書き方が基本になります。

### 動的ライブラリ

`nidonehsp` では一部のプラットフォームで動的ライブラリの読み込みと外部関数の呼び出しをサポートしています。

|プラットフォーム|動的ライブラリの使用可否|備考|
|:--|:--|:--|
|Windows|〇|32 ビットでは stdcall 呼び出し規約<br>64 ビットでは Windows で定められた呼び出し規約|
|HTML|×||

外部関数の呼び出しでは HSP3 と違い 内部エンコーディングが UTF8 の関係もあり、文字列の型指定子として `u8str`、また`int` の 64 ビット化に伴い `int64` などが追加されています。

詳細についてはヘルプビューの `#uselib` を参照してください。

### COMのサポート

`nidonehsp` はクロスプラットフォームを前提にしているため、COM についてはサポートされていません。

### 使える命令、使えない命令

HSP3 からの移行で、具体的にどの命令が使えてどの命令が使えないか分かりにくいこととがあると思います。

`nidonehsp` はエディタとして VSCode を推奨としており、VSCode 上ではスクリプト中の組み込み命令はカラーリングされます。

また、該当の命令にカーソルを合わせた状態で F1 （デフォルトキーバインディング）を押すとその命令のヘルプを見ることができます。

このように、ある程度のエディタ機能や実行ファイルへのパッケージングなどは VSCode 用の拡張として整備していっていますので、可能であれば VSCode による開発環境を整えて頂ければと思います。

開発環境について詳細は[開発環境][1]を参照してください。

### 描画システム

`nidonehsp` では描画のバックエンドとして `OpenGL ES 3.0` をメインターゲットとしています。

これはクロスプラットフォームを見据えた設計によるものですが、`OpenGL` を使った描画であり、HSP3 とは違い描画は GPU で行われます。

`OpenGL` と聞くと HSP3 の `hgimg4` を連想してしまうかもしれませんが、現在 `nidonehsp` が目標としている互換性のターゲットは Windows 版 GUI ランタイムになります。\
なので、`hgimg4` 特有の `redraw 0` によって画面がクリアされる、といった処理にはなっていないことに注意してください。

基本的な描画は勿論、`redraw` などによる描画の一時的な停止、`button` などのウィジェットの挙動は `OpenGL` 上でエミュレートされます。\
`input` などのウィジェットは `OpenGL` 上でエミュレートされており、IME がうまくでないですが、日本語などOSネイティブな言語入力はサポートされています。

とはいえ、GPU を使った描画であり、`mref` を使った VRAM メモリへの書き換えには対応していません。\
それらについては `hgimg4` でサポートされている `celbitmap` などを使う必要があるなど、イマイチ対応がちぐはぐに見えてしまう箇所もあります。

`nidonehsp` としては挙動を HSP3 に完全に合わせられたら理想とは考えていますが、そうするとクロスプラットフォームという壁を容易に超えられない、ということもあり、`nidonehsp` 独自の挙動になっている事はご理解ください。

なるべく命令の処理内容についてはヘルプビューにて記述しようとは考えていますので、適宜ご指摘いただければと思います。

### フォントの描画

`nidonehsp` ではフォントの描画システムは大別して 2 系統存在します。

1 つは、大きなテクスチャにフォントに含まれるグリフ（字形）を予めベイクしておき、それを使ってテクスチャを貼り付けて文字列描画とする処理です。

もう 1 つは、CPU を使ってテクスチャに直接ベイク（レンダリング）する処理です。

説明のため、1 つめ（前者）の手法をテクスチャによる文字列描画、2 つめ（後者）をベイクによる文字列描画、として以下説明していきます。

#### テクスチャによる文字列描画

これは `mes` 命令などでの挙動で、`mes` 命令で文字列を描画する際、システムが持っているテクスチャ（アトラス）から該当するグリフを含む箇所を UV 指定で描画する、という処理です。

`mes` で描画するグリフがテクスチャに含まれてない場合、オンデマンドでグリフがテクスチャにベイクされます。

ただし、アトラステクスチャのサイズは固定となっているため、アトラステクスチャに収まらない場合はグリフのベイクがキャンセルされ、代替文字のグリフが描画に使われます。

この手法は初回のみグリフのベイクがあるためCPU負荷が高いですが、その後は文字列は全てGPUを使って描画されるため高速で動作するというメリットがあります。

一方で、大量にグリフを描画する場合は描画できないグリフが出てきてしまうなど問題もあります。\
また、グリフの解像度はベイク時に固定されているため、大きなスケールで文字列を描画すると解像度の粗が目立ってしまいます。

※デフォルトのフォントでは、ベイク時のフォント高さは `18` で固定されています。\
　ただし、ベイク時のフォント高さは `fontload@n2` などの命令でフォント登録時に指定することはできます。
　現在、アトラステクスチャのサイズはフォント毎に独立で、 `2048 x 2048` で固定されています。\

#### ベイクによる文字列描画

これは `picmes@n2` 命令などでの挙動で、都度 `picmes@n2` 命令時に該当のウィンドウへ文字列をベイクする挙動です。

都度ベイクする際に指定したフォントの高さを考慮したラスタライズを行うので、どのようなスケールでも文字列をそのままの解像度で描画できるメリットがあります。

一方で、対象のウィンドウの内容をCPUから書き換えるため、一度GPUの書き出しをストップし、CPUで書き換えてからアップロードする処理になり、決して軽い処理ではありません。

#### どちらの文字列描画を使うべきか

`nidonehsp` としては、次のように段階的に判断をしていただければと思っています。

1. 速度の面で最も問題が少なく、システムとして面倒な動作はなるべく引き受けているため、第一選択肢としては `mes` を推奨します。
1. スケールの大きな文字列描画などでテクスチャの解像度が問題になることもあります。\
その場合、自然と選択肢はベイクによる文字列描画になります。\
`mes` を `picmes@n2` に置き換えてみてください。\
処理コストが問題ないようであればそのまま実装していただければと思います。
1. ベイクによる文字列描画で処理コストが無視できない場合、手間はかかりますが下記の対応を行うことで処理コストを削減できます。\
予め別のウィンドウ（バッファ）に、最初に一度だけ `picmes@n2` で高解像度で文字列を描画しておき、画面に描画する際はそのウィンドウから `gcopy` などの命令で文字列の描画を行う処理です。\
この場合、スクリプト側の対応も必要で、バッファ管理も必要になりますが、品質及び速度の面で問題が少ないです。

※将来的には、手順の最後のようにベイクによる文字列の自動バッファ機能など、フォントの描画についてはもう少し手を入れる予定はあります。

# ライセンス全文

`nidonehsp` 自身は NYSL でライセンスされています。

```
nidonehsp is licensed under NYSL(煮るなり焼くなり好きにしろライセンス):

ライセンス：
    NYSL Version 0.9982
    A. 本ソフトウェアは Everyone'sWare です。このソフトを手にした一人一人が、
        ご自分の作ったものを扱うのと同じように、自由に利用することが出来ます。
        A-1. フリーウェアです。作者からは使用料等を要求しません。
        A-2. 有料無料や媒体の如何を問わず、自由に転載・再配布できます。
        A-3. いかなる種類の 改変・他プログラムでの利用 を行っても構いません。
        A-4. 変更したものや部分的に使用したものは、あなたのものになります。
            公開する場合は、あなたの名前の下で行って下さい。
    B. このソフトを利用することによって生じた損害等について、作者は
        責任を負わないものとします。各自の責任においてご利用下さい。
    C. 著作者人格権は exrd に帰属します。著作権は放棄します。
    D. 以上の３項は、ソース・実行バイナリの双方に適用されます。

in English:
    A. This software is "Everyone'sWare". It means:
    Anybody who has this software can use it as if he/she is
    the author.

    A-1. Freeware. No fee is required.
    A-2. You can freely redistribute this software.
    A-3. You can freely modify this software. And the source
    may be used in any software with no limitation.
    A-4. When you release a modified version to public, you
    must publish it with your name.

    B. The author is not responsible for any kind of damages or loss
    while using or misusing this software, which is distributed
    "AS IS". No warranty of any kind is expressed or implied.
    You use AT YOUR OWN RISK.

    C. Copyrighted to exrd

    D. Above three clauses are applied both to source and binary
    form of this software.
```

`nidonehsp` が依存するライブラリの中で、特筆すべきライブラリとそのライセンスは次の表の通りです。

|ライブラリ|使用プラットフォーム|ライセンス|
|:--|:--|:--|
|SDL2|全て|zlib|
|emscripten|HTML|MIT<br>University of Illinois/NCSA Open Source License|

各プラットフォームにおけるバイナリのライセンス表記については上記表に従って行ってください。

現状、Windows のバイナリではライセンス表記は必要ありません。

[1]:developmentEnvironment.md
